{
    "asv.app_suite.QAOA_heavy.peakmem_minvertex_heavy": {
        "code": "class QAOA_heavy:\n    def peakmem_minvertex_heavy(self):\n        \"\"\"Benchmark the peak memory usage of a QAOA algorithm for finding the minimum vertex cover\n        of a large graph.\"\"\"\n        hyperparams = {'n_layers': self.n_layers,\n                       'graph': self.graph}\n        benchmark_qaoa(hyperparams)",
        "name": "asv.app_suite.QAOA_heavy.peakmem_minvertex_heavy",
        "param_names": [],
        "params": [],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "1a1ef6edb9b281ad15253d01c0a9f82754f674a626c23d5620a9f69388e3e44f"
    },
    "asv.app_suite.QAOA_heavy.time_minvertex_heavy": {
        "code": "class QAOA_heavy:\n    def time_minvertex_heavy(self):\n        \"\"\"Time a QAOA algorithm for finding the minimum vertex cover of a large graph.\"\"\"\n        hyperparams = {'n_layers': self.n_layers,\n                       'graph': self.graph}\n        benchmark_qaoa(hyperparams)",
        "min_run_count": 2,
        "name": "asv.app_suite.QAOA_heavy.time_minvertex_heavy",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b5f4aaa479191c9d8d14720c1b30502c4a3d924bbd83cf798b25b50d0721a9dd",
        "warmup_time": -1
    },
    "asv.app_suite.QAOA_light.peakmem_minvertex_light": {
        "code": "class QAOA_light:\n    def peakmem_minvertex_light(self, n_layers):\n        \"\"\"Benchmark the peak memory usage of QAOA algorithm for finding the minimum vertex cover of\n        a small graph.\"\"\"\n        hyperparams = {'n_layers': n_layers}\n        benchmark_qaoa(hyperparams)",
        "name": "asv.app_suite.QAOA_light.peakmem_minvertex_light",
        "param_names": [
            "n_layers"
        ],
        "params": [
            [
                "1",
                "5"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "48c6d232736ffe4bea99669f6d182d22850eea0ff189e270ee5133944ec95c35"
    },
    "asv.app_suite.QAOA_light.time_minvertex_light": {
        "code": "class QAOA_light:\n    def time_minvertex_light(self, n_layers):\n        \"\"\"Time a QAOA algorithm for finding the minimum vertex cover of a small graph.\"\"\"\n        hyperparams = {'n_layers': n_layers}\n        benchmark_qaoa(hyperparams)",
        "min_run_count": 2,
        "name": "asv.app_suite.QAOA_light.time_minvertex_light",
        "number": 0,
        "param_names": [
            "n_layers"
        ],
        "params": [
            [
                "1",
                "5"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "82caac865c28020034aee141138d61e6cc399ab1c78c265c05aab76b936bfd91",
        "warmup_time": -1
    },
    "asv.app_suite.VQE_heavy.peakmem_lih": {
        "code": "class VQE_heavy:\n    def peakmem_lih(self, optimize):\n        \"\"\"Benchmark the peak memory usage of the VQE algorithm for the lithium hydride molecule.\"\"\"\n    \n        hyperparams = {'ham': self.ham,\n                       'ansatz': self.ansatz,\n                       'params': self.parameters,\n                       'device': self.device,\n                       'optimize': optimize}\n    \n        benchmark_vqe(hyperparams)\n\n    def setup(self, optimize):\n    \n        electrons = 2\n        qubits = 8\n    \n        singles, doubles = qchem.excitations(electrons, qubits)\n        s_wires, d_wires = qchem.excitations_to_wires(singles, doubles)\n        hf_state = qchem.hf_state(electrons, qubits)\n    \n        self.ham = ham_lih\n    \n        self.ansatz = partial(UCCSD, init_state=hf_state, s_wires=s_wires, d_wires=d_wires)\n    \n        self.parameters = np.array([6.39225682, -0.99471664, -4.2026237, -4.48579097, 9.8033157,\n                               1.19030864, -3.89924719, 7.25037131, -0.95897967, -0.75287453,\n                               0.92252162, 1.10633277, 0.94911997, 1.09138887, 5.27297259])\n    \n        self.device = qml.device('default.qubit', wires=qubits)",
        "name": "asv.app_suite.VQE_heavy.peakmem_lih",
        "param_names": [
            "optimize"
        ],
        "params": [
            [
                "False",
                "True"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ce4621ca7f1b797e214e5cfc919b491fccbcdb5833c8ae1aad24dc6849477faa"
    },
    "asv.app_suite.VQE_heavy.time_lih": {
        "code": "class VQE_heavy:\n    def time_lih(self, optimize):\n        \"\"\"Time the VQE algorithm for the lithium hydride molecule.\"\"\"\n    \n        hyperparams = {'ham': self.ham,\n                       'ansatz': self.ansatz,\n                       'params': self.parameters,\n                       'device': self.device,\n                       'optimize': optimize}\n    \n        benchmark_vqe(hyperparams)\n\n    def setup(self, optimize):\n    \n        electrons = 2\n        qubits = 8\n    \n        singles, doubles = qchem.excitations(electrons, qubits)\n        s_wires, d_wires = qchem.excitations_to_wires(singles, doubles)\n        hf_state = qchem.hf_state(electrons, qubits)\n    \n        self.ham = ham_lih\n    \n        self.ansatz = partial(UCCSD, init_state=hf_state, s_wires=s_wires, d_wires=d_wires)\n    \n        self.parameters = np.array([6.39225682, -0.99471664, -4.2026237, -4.48579097, 9.8033157,\n                               1.19030864, -3.89924719, 7.25037131, -0.95897967, -0.75287453,\n                               0.92252162, 1.10633277, 0.94911997, 1.09138887, 5.27297259])\n    \n        self.device = qml.device('default.qubit', wires=qubits)",
        "min_run_count": 2,
        "name": "asv.app_suite.VQE_heavy.time_lih",
        "number": 0,
        "param_names": [
            "optimize"
        ],
        "params": [
            [
                "False",
                "True"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "332b21db76a0497caf7573fe3c0e53d404e680615b59c1b427b43cee05ebd174",
        "warmup_time": -1
    },
    "asv.app_suite.VQE_light.peakmem_hydrogen": {
        "code": "class VQE_light:\n    def peakmem_hydrogen(self, n_steps, optimize):\n        \"\"\"Benchmark the peak memory usage of the VQE algorithm with the UCCSD ansatz for computing\n         the ground state energy of the hydrogen molecule.\"\"\"\n        hyperparams = {'n_steps': n_steps,\n                       'optimize': optimize}\n        benchmark_vqe(hyperparams)",
        "name": "asv.app_suite.VQE_light.peakmem_hydrogen",
        "param_names": [
            "n_steps",
            "optimize"
        ],
        "params": [
            [
                "1",
                "3"
            ],
            [
                "False",
                "True"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "65a1e228b4810ae651090355a1907ed86e1a11a2f850fccba1f201e5c20d57d0"
    },
    "asv.app_suite.VQE_light.time_hydrogen": {
        "code": "class VQE_light:\n    def time_hydrogen(self, n_steps, optimize):\n        \"\"\"Time a VQE algorithm with the UCCSD ansatz for computing the ground state energy of the\n         hydrogen molecule.\"\"\"\n        hyperparams = {'n_steps': n_steps,\n                       'optimize': optimize}\n        benchmark_vqe(hyperparams)",
        "min_run_count": 2,
        "name": "asv.app_suite.VQE_light.time_hydrogen",
        "number": 0,
        "param_names": [
            "n_steps",
            "optimize"
        ],
        "params": [
            [
                "1",
                "3"
            ],
            [
                "False",
                "True"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c1f3b5fbeb3a46c492db1e4125d3b6dad20a35a1509588b2ffa1ef27f7354255",
        "warmup_time": -1
    },
    "asv.core_suite.CircuitEvaluation.time_circuit": {
        "code": "class CircuitEvaluation:\n    def time_circuit(self, n_wires, n_layers):\n        \"\"\"Time a simple default circuit.\"\"\"\n        hyperparams = {'n_wires': n_wires,\n                       'n_layers': n_layers}\n        benchmark_circuit(hyperparams)",
        "min_run_count": 2,
        "name": "asv.core_suite.CircuitEvaluation.time_circuit",
        "number": 0,
        "param_names": [
            "n_wires",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5",
                "10"
            ],
            [
                "3",
                "6",
                "9"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "23e6c66e4ae044652eab3c30a01d8193cadbc1d200d6d64b7fd48c9dbf04885d",
        "warmup_time": -1
    },
    "asv.core_suite.GradientComputation.time_gradient_autograd": {
        "code": "class GradientComputation:\n    def time_gradient_autograd(self, n_wires, n_layers):\n        hyperparams = {'n_wires': n_wires,\n                       'n_layers': n_layers,\n                       'interface': 'autograd'}\n        benchmark_gradient(hyperparams)",
        "min_run_count": 2,
        "name": "asv.core_suite.GradientComputation.time_gradient_autograd",
        "number": 0,
        "param_names": [
            "n_wires",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5"
            ],
            [
                "3",
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ed30a0169eec20970901c4a1cf6a779a1a7f6ff5e90593cfccca498fe7298e0d",
        "warmup_time": -1
    },
    "asv.core_suite.GradientComputation.time_gradient_tf": {
        "code": "class GradientComputation:\n    def time_gradient_tf(self, n_wires, n_layers):\n        hyperparams = {'n_wires': n_wires,\n                       'n_layers': n_layers,\n                       'interface': 'tf'}\n        benchmark_gradient(hyperparams)",
        "min_run_count": 2,
        "name": "asv.core_suite.GradientComputation.time_gradient_tf",
        "number": 0,
        "param_names": [
            "n_wires",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5"
            ],
            [
                "3",
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "501fd7e2d47f73ba86852bb1284bec48cf1d7362dca5acdb0011bec6ff3762a9",
        "warmup_time": -1
    },
    "asv.core_suite.GradientComputation.time_gradient_torch": {
        "code": "class GradientComputation:\n    def time_gradient_torch(self, n_wires, n_layers):\n        hyperparams = {'n_wires': n_wires,\n                       'n_layers': n_layers,\n                       'interface': 'torch'}\n        benchmark_gradient(hyperparams)",
        "min_run_count": 2,
        "name": "asv.core_suite.GradientComputation.time_gradient_torch",
        "number": 0,
        "param_names": [
            "n_wires",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5"
            ],
            [
                "3",
                "6"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1c8c22b277b9a814fe7d6ff1eec23c0a4ef9e0aefcecd1299188479656392243",
        "warmup_time": -1
    },
    "asv.core_suite.Optimization.time_optimization_autograd": {
        "code": "class Optimization:\n    def time_optimization_autograd(self):\n        \"\"\"Time gradient descent on the default circuit using autograd.\"\"\"\n        hyperparams = {'interface': 'autograd'}\n        benchmark_optimization(hyperparams, n_steps=10)",
        "min_run_count": 2,
        "name": "asv.core_suite.Optimization.time_optimization_autograd",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d91d25cd634a1f52a44899408323e4746c6a75cd97f0be51bdcf224a7c13f23d",
        "warmup_time": -1
    },
    "asv.core_suite.Optimization.time_optimization_tf": {
        "code": "class Optimization:\n    def time_optimization_tf(self):\n        \"\"\"Time gradient descent on the default circuit using tf.\"\"\"\n        hyperparams = {'interface': 'tf'}\n        benchmark_optimization(hyperparams, n_steps=10)",
        "min_run_count": 2,
        "name": "asv.core_suite.Optimization.time_optimization_tf",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b8c6bc96d0393f95496b1803ad8fa0335db1d196030d27be285910d1c65e39a4",
        "warmup_time": -1
    },
    "asv.core_suite.Optimization.time_optimization_torch": {
        "code": "class Optimization:\n    def time_optimization_torch(self):\n        \"\"\"Time gradient descent on the default circuit using torch.\"\"\"\n        hyperparams = {'interface': 'torch'}\n        benchmark_optimization(hyperparams, n_steps=10)",
        "min_run_count": 2,
        "name": "asv.core_suite.Optimization.time_optimization_torch",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "63df0016c0a5542fff7d6093219db9145b836a0e020f9d6cb73235aa4a8401d1",
        "warmup_time": -1
    },
    "asv.device_suite.CircuitEvaluation.time_circuit": {
        "code": "class CircuitEvaluation:\n    def time_circuit(self, dev, n_wires, n_layers):\n        \"\"\"Time a simple default circuit.\"\"\"\n        hyperparams = {'n_wires': n_wires,\n                       'n_layers': n_layers,\n                       'device': dev}\n        benchmark_circuit(hyperparams)",
        "min_run_count": 2,
        "name": "asv.device_suite.CircuitEvaluation.time_circuit",
        "number": 0,
        "param_names": [
            "device",
            "n_wires",
            "n_layers"
        ],
        "params": [
            [
                "'default.qubit'",
                "'lightning.qubit'",
                "'default.mixed'",
                "'qiskit.aer'",
                "'qiskit.basicaer'",
                "'cirq.simulator'",
                "'cirq.pasqal'",
                "'cirq.qsim'",
                "'qulacs.simulator'"
            ],
            [
                "2",
                "5",
                "10"
            ],
            [
                "3",
                "6",
                "9"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1659c2144ffffaf170b492786638f723f0985cbc6cb0657f38a71cb558010529",
        "warmup_time": -1
    },
    "version": 2
}
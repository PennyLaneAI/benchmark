{
    "benchmark_numpy.NumpyCircuit.time_iqp": {
        "code": "class NumpyCircuit:\n    def time_iqp(self, n_qubits, n_layers):\n    \t\"\"\"IQP circuit benchmark.\n    \t\"\"\"\n    \trandom_iqp_wires = random.sample(range(n_qubits), ceil(min(2, n_qubits) * random.random()))\n    \tdev = qml.device('default.qubit', wires=n_qubits)\n    \n    \t@qml.qnode(dev)\n    \tdef circuit():\n    \t\t\"\"\"Mutable IQP quantum circuit.\"\"\"\n    \t\tfor i in range(n_qubits):\n    \t\t\tqml.Hadamard(i)\n    \n    \t\tfor i in range(n_layers * n_qubits):\n    \t\t\twires = random_iqp_wires\n    \t\t\tif len(wires) == 1:\n    \t\t\t\tqml.PauliZ(wires=wires)\n    \t\t\telif len(wires) == 2:\n    \t\t\t\tqml.CZ(wires=wires)\n    \t\t\telif len(wires) == 3:\n    \t\t\t\tqml.CCZ(wires)\n    \n    \t\tfor i in range(n_qubits):\n    \t\t\tqml.Hadamard(i)\n    \n    \t\treturn qml.expval(qml.PauliZ(0))\n    \n    \tcircuit()",
        "min_run_count": 2,
        "name": "benchmark_numpy.NumpyCircuit.time_iqp",
        "number": 0,
        "param_names": [
            "n_qubits",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5",
                "10"
            ],
            [
                "1",
                "4",
                "8"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4a6be8ccab91a9d4ec395e8a946d323d933bf67110f7946babf378bf3957bfc1",
        "warmup_time": -1
    },
    "benchmark_numpy.NumpyCircuit.time_nearest_neighbour": {
        "code": "class NumpyCircuit:\n    def time_nearest_neighbour(self, n_qubits, n_layers):\n    \t\"\"\"Nearest-neighbour circuit benchmark.\n    \n    \tCreates a parametrized quantum circuit with n layers.\n    \tEach layer consists of single-qubit parametrized rotations,\n    \tand two-qubit gates between nearest-neighbour qubits.\n    \t\"\"\"\n    \tparams1 = np.random.uniform(high=2 * pi, size=(n_layers, n_qubits))\n    \tparams2 = np.random.uniform(high=2 * pi, size=(n_layers, n_qubits - 1))\n    \tall_wires = range(n_qubits)\n    \tdev = qml.device('default.qubit', wires=n_qubits)\n    \n    \t@qml.qnode(dev)\n    \tdef circuit():\n    \t\tfor layer in range(n_layers):\n    \t\t\tqml.broadcast(\n    \t\t\t\tqml.RX, pattern=\"single\", wires=all_wires, parameters=params1[layer],\n    \t\t\t)\n    \t\t\tqml.broadcast(\n    \t\t\t\tqml.CRY, pattern=\"chain\", wires=all_wires, parameters=params2[layer],\n    \t\t\t)\n    \t\t\treturn qml.expval(qml.PauliZ(0))\n    \n    \tcircuit()",
        "min_run_count": 2,
        "name": "benchmark_numpy.NumpyCircuit.time_nearest_neighbour",
        "number": 0,
        "param_names": [
            "n_qubits",
            "n_layers"
        ],
        "params": [
            [
                "2",
                "5",
                "10"
            ],
            [
                "1",
                "4",
                "8"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "533785d472c0941e59396345e26919b66eb1b7c6e747d96b1f8761fa50ac12a3",
        "warmup_time": -1
    },
    "benchmark_numpy.NumpyGradient.time_rotations": {
        "code": "class NumpyGradient:\n    def time_rotations(self, n_qubits, n_params):\n    \t\"\"\"Rotations gradient benchmark.\n    \n    \tThe circuit consists of rotations applied to consecutive wires,\n    \tstarting from wire 0 after the last wire is reached.\n    \t\"\"\"\n    \tparams = np.random.uniform(high=2 * pi, size=n_params)\n    \tdev = qml.device('default.qubit', wires=n_qubits)\n    \n    \t@qml.qnode(dev)\n    \tdef circuit(params):\n    \t\tfor i, w in enumerate(params):\n    \t\t\tqml.RX(w, wires=i % n_qubits)\n    \t\treturn qml.expval(qml.PauliZ(wires=n_qubits-1))\n    \n    \tcircuit.jacobian([params])",
        "min_run_count": 2,
        "name": "benchmark_numpy.NumpyGradient.time_rotations",
        "number": 0,
        "param_names": [
            "n_qubits",
            "n_params"
        ],
        "params": [
            [
                "2",
                "5",
                "10"
            ],
            [
                "5",
                "20",
                "40"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4323ba6bebcf76c78e17648bf2fb10c88f363eeb1ec0aadb017c6bc4ce6de0ab",
        "warmup_time": -1
    },
    "version": 2
}